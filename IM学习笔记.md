# IM Study Notes
（学习 地址 http://www.52im.net  博主 JackJiang  部分百度 图基本照抄 - -）
##1 网络通信协议
###1.1 OSI7层模型 TCP/IP5层模型
各层名称及对应协议和工作设备
![模型对应协议](https://images2015.cnblogs.com/blog/705728/201604/705728-20160424234827195-1493107425.png)
![模型对应工作设备](https://images2015.cnblogs.com/blog/705728/201604/705728-20160424234826351-1957282396.png)
####1.1.1 物理层
实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。
####1.1.2 数据链路层
它在"物理层"的上方，确定了0和1的分组方式，将比特组合成字节,再将字节组合成帧,使用链路层地址。
#####1.1.2.1 以太网协议
以太网规定，一组电信号构成一个数据包，叫做"帧"（Frame）。每一帧分成两个部分：标头（Head）和数据（Data)。

![以太网帧组成](http://www.52im.net/data/attachment/forum/201811/01/150929cw8a20dzzlonkene.jpg)

“Head"包含数据包的一些说明项，比如发送者、接受者、数据类型等等；"Data"则是数据包的具体内容。

"Head"的长度，固定为18字节。"Data"的长度，最短为46字节，最长为1500字节。因此，整个"帧"最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。
#####1.1.2.2 MAC地址
以太网规定，连入网络的所有设备，都必须具有"网卡"接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址，长度是48个二进制位，通常用12个十六进制数表示。
![MAC地址示例](http://www.52im.net/data/attachment/forum/201811/01/150918zzkluk96tufsl3bs.jpg)


前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。
#####1.1.2.3 广播
以太网的数据传播是向本网络的计算机全网发送数据包
由每个计算机读取Head判断是需要处理包还是丢弃这个包。


数据包的定义、网卡的MAC地址、广播的发送方式，"链接层"就可以在多台计算机之间传送数据


####1.1.3 网络层
互联网是无数子网络共同组成的一个巨型网络，不同的子网络通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。
#####1.1.3.1 IP协议
规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。目前，广泛采用的是IP协议第四版，简称IPv4。
IPv4这个版本规定，网络地址由32个二进制位组成：

![IP地址示例](http://www.52im.net/data/attachment/forum/201811/01/150947elp4lvaiiesuvlyu.jpg)


习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。IP地址分为两部分，前一部分代表所在网络后一部分代表主机，通过子网掩码与不同的IP地址进行2进制AND运算判断其IP地址是否在同一个网络（AND运算的结果相同则在同一网络）
#####1.1.3.2 IP数据包
具体来说，IP数据包也分为"Head"和"Data"两个部分，"Head"部分主要包括版本、长度、IP地址等信息,"Data"部分则是IP数据包的具体内容，将其放入以太数据包中就变成了：
![IP数据包放入以太数据包](http://www.52im.net/data/attachment/forum/201811/01/151007ibebhdrudjqof1qp.jpg)

IP数据包的"标头"部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的"数据"部分，最长为65,515字节。前面说过，以太网数据包的"数据"部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。
#####1.1.3.3 ARP协议
地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址。我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。
####1.1.4 传输层
端口："端口"是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户的应用程序只能选用大于1023的端口。

“传输层"的功能，就是建立"端口到端口"的通信。相比之下，"网络层"的功能是建立"主机到主机"的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做"套接字"（socket）。有了它，就可以进行网络应用程序开发了。
#####1.1.4.1 UDP协议
我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议。
UDP数据包也是由"Head"和"Data"组成的
"Head"部分主要定义了发出端口和接收端口，"Data"部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的"数据"部分，而前面说过，IP数据包又是放在以太网数据包之中：
![UDP数据包咋以太网中传输](http://www.52im.net/data/attachment/forum/201811/01/151011eysfi272f6nveevs.jpg)

"Head"部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。
#####1.1.4.2 TCP协议
UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。

因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。

TCP数据包和UDP数据包一样，都是内嵌在IP数据包的"数据"部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。
####1.1.5 应用层
应用程序收到"传输层"的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。"应用层"的作用，就是规定应用程序的数据格式(HTTP/SMTP...)
它的数据就放在TCP数据包的"数据"部分，以太网数据包就变成了：
![应用层数据包在以太网中](http://www.52im.net/data/attachment/forum/201811/01/151016iaeia7apeacny25l.jpg)

###小结：
数据包结构： 以太网Head+IPHead+TCPHead+AppData

发送数据包需要知道两个地址 ：

*  目标MAC地址
*  目标IP地址

MAC地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，必须通过网关（gateway）转发。数据包的目标地址，实际上分成两种情况：

*  同一个子网络 目标MAC地址、IP地址
*  不同子网络 网关的MAC地址、目标的IP地址
####1.2 上网设置
上网的四个设置：
* 本机IP地址
* 子网掩码
* 网关IP地址
* DNS的IP地址
#####1.2.1 DNS
域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用TCP和UDP端口53[1]。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。
#####1.2.2 静态IP地址
一般是运营商的专网服务才会有固定的IP地址，民用宽带都是动态IP地址
#####1.2.3 动态IP地址
所谓"动态IP地址"，指计算机开机后，会自动分配到一个IP地址，不用人为设定。它使用的协议叫做DHCP协议。

这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做"DHCP服务器"。新的计算机加入网络，必须向"DHCP服务器"发送一个"DHCP请求"数据包，申请IP地址和相关的网络参数。

前面说过，如果两台计算机在同一个子网络，必须知道对方的MAC地址和IP地址，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？DHCP协议做了一些巧妙的规定。
#####1.2.4 DHCP协议
首先，它是一种应用层协议，建立在UDP协议之上，所以整个数据包是这样的：
![DHCP协议数据包](http://www.52im.net/data/attachment/forum/201811/01/153032wppxuuvdmupaqiy6.jpg)



* 最前面的"以太网标头"：设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。

* 后面的"IP标头"：设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。

* 最后的"UDP标头"：设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。

* 这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道"这个包是发给我的"，而其他计算机就可以丢弃这个包

* 接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个"DHCP响应"数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。

*  新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。

###小结 实例：访问网页
1. 属于地址（WWW万维网域名地址）
2. 发送DNS数据包通过DNS服务器返回的数据包获得实际网页的IP地址
3. 通过子网掩码判断IP是否处在同一网络下 
 * 是：直接发送应用层数据包
 * 否：通过网关地址转发应用层数据包
4. 数据包 格式（HTTP）： 
![HTTP协议格式](http://www.52im.net/data/attachment/forum/201811/01/152959qwuepu61p36qpu5l.jpg)
如果数据包大小超过了以太网协议数据包大小贼分割成多个包传输：
![以太网分包传输](http://www.52im.net/data/attachment/forum/201811/01/152701ig00c96izody9qz9.jpg)
5. 服务器响应
 经过多个网关的转发，服务器收到多个以太网数据包。根据IP标头的序号，将几个包拼起来，取出完整的TCP数据包，然后读出里面的"HTTP请求"，接着做出"HTTP响应"，再用TCP协议发回来。
	
本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。

###1.3 TCP协议详解
互联网由一整套协议构成，TCP 是以太网协议和 IP 协议的上层协议，也是应用层协议的下层协议


![互联网协议](http://www.52im.net/data/attachment/forum/201710/12/120246jsjzwjq6l6i9zi51.png)


* 最底层的以太网协议（Ethernet）规定了电子信号如何组成数据包（packet），解决了子网内部（局域网）的点对点通信。

*  IP 协议可以连接多个局域网， 路由器就是基于 IP 协议。局域网之间要靠路由器连接，路由器内部有一张路由表，本机的路由表注明了不同 IP 目的地的数据包，要发送到哪一个网口（interface）IP 协议只是一个地址协议，并不保证数据包的完整。如果路由器丢包（比如缓存满了，新进来的数据包就会丢失），就需要发现丢了哪一个包，以及如何重新发送这个包。这就要依靠 TCP 协议。
####1.3.1 TCP数据包大小
 以太网数据包（packet）的大小是固定的，最初是1518字节，后来增加到1522字节。其中， 1500 字节是负载（payload），22字节是头信息（head）。IP 数据包在以太网数据包的负载里面，它也有自己的头信息，最少需要20字节，所以[ IP 数据包的负载最多为1480字节]()。TCP 数据包在 IP 数据包的负载里面。它的头信息最少也需要20字节，因此 TCP 数据包的最大负载是 1480 - 20 = 1460 字节。由于 IP 和 TCP 协议往往有额外的头信息，所以[ TCP 负载实际为1400字节左右]()。因此，一条1500字节的信息需要两个 TCP 数据包。[HTTP/2 协议的一大改进， 就是压缩 HTTP 协议的头信息，使得一个 HTTP 请求可以放在一个 TCP 数据包里面，而不是分成多个，这样就提高了速度]()。
####1.3.2 TCP数据包的编号（SEQ）
TCP最多最多负载1400字节，一次性发送大量数据，就需要分成多个包，发送的时候，TCP 协议为每个包编号（sequence number，简称 SEQ）

第一个包的编号是一个随机数。每个数据包都可以得到两个编号：自身的编号，以及下一个包的编号。而两包编号的差值就可以知道该包的负载是多少字节
####1.3.3 TCP数据包的组装
* 收到TCP数据包后组装还原是由操作系统完成
* 组装还原后通过TCP中的端口参数指定转交给监听该端口的应用程序
* 应用程序收到组装好的数据后，再根据具体的应用协议正确读出数据（以浏览器为例，就会根据 HTTP 协议的 Content-Length 字段正确读出一段段的数据，一次 TCP 通信可以包括多个 HTTP 通信。）
####1.3.4 慢启动和ACK
服务器发送数据包，当然越快越好，最好一次性全发出去。但是，发得太快，就有可能丢包。带宽小、路由器过热、缓存溢出等许多因素都会导致丢包。线路不好的话，发得越快，丢得越多。

TCP 协议为了做到效率与可靠性的统一，设计了一个慢启动（slow start）机制。开始的时候，发送得较慢，然后根据丢包的情况，调整速率：如果不丢包，就加快发送速度；如果丢包，就降低发送速度。

inux 内核里面设定了（常量[TCP_NIT _CWND]()），刚开始通信的时候，发送方一次性发送10个数据包，即"发送窗口"的大小为10。然后停下来，等待接收方的确认，再继续发送。默认情况下，接收方每收到两个 TCP 数据包，就要发送一个确认消息。"确认"的英语是 acknowledgement，所以这个确认消息就简称 ACK。
ACK携带两个信息：

* [期待要收到的下一个数据包的编号]() 
* [接收方的接受窗口剩余容量]()

由于 TCP 通信是双向的，所以双方都需要发送 ACK。两方的窗口大小，很可能是不一样的。而且 ACK 只是很简单的几个字段，通常与数据合并在一个数据包里面发送。

[即使对于带宽很大、线路很好的连接，TCP 也总是从10个数据包开始慢慢试，过了一段时间以后，才达到最高的传输速率。这就是 TCP 的慢启动]()。
####1.3.5 数据包的遗失处理
每一个数据包都带有下一个数据包的编号。如果下一个数据包没有收到，那么 ACK 的编号就不会发生变化。

如果发送方发现收到三个连续的重复 ACK，或者超时了还没有收到任何 ACK，就会确认丢包，即5号包遗失了，从而再次发送这个包。通过这种机制，TCP 保证了不会有数据包丢失。
  
###1.4 TCP和UDP的差异

####1.4.1 简历连接的方式差异
* TCP

建立连接三次握手，断开连接四次挥手，建立连接主要是用来初始化资源和告诉对方 我方的序列号

1）client端首先发送一个SYN包告诉Server端我的初始序列号是X；

2）Server端收到SYN包后回复给client一个ACK确认包，告诉client说我收到了；

3）接着Server端也需要告诉client端自己的初始序列号，于是Server也发送一个SYN包告诉client我的初始序列号是Y；

4）Client收到后，回复Server一个ACK确认包说我知道了

2、3步简化为一步就是建立连接的三次握手

* UDP

UDP是广播形式的传送，而 UDP 是面向数据包的、不可靠的、无序的传输协议

####1.4.2 数据发送方式的差异
* TCP：

由于 TCP 是建立在两端连接之上的协议，所以理论上发送的数据流不存在大小的限制。但是由于缓冲区有大小限制，所以你如果用 TCP 发送一段很大的数据，可能会截断成好几段，接收方依次的接收。

* UDP：

由于 UDP 本身发送的就是一份一份的数据报，所以自然而然的就有一个上限的大小，决定数据报大小的因素有：

* UDP协议本身，UDP协议中有16位的UDP报文长度，那么UDP报文长度不能超过2^16=65536；
* 以太网(Ethernet)数据帧的长度，数据链路层的MTU(最大传输单元)；
* socket的UDP发送缓存区大小。

先来看第一个因素，UDP 本身协议的报文长度为 2^16 - 1，UDP 包头占 8 个字节，IP 协议本身封装后包头占 20 个字节，所以最终长度为： 2^16 - 1 - 20 - 8 = 65507 字节。

只看第一个因素有点理想化了，因为 UDP 属于不可靠协议，我们应该尽量避免在传输过程中，数据包被分割。所以这里有一个非常重要的概念 MTU -- 也就是最大传输单元。

在 Internet 下 MTU 的值为 576 字节，所以在 internet 下使用 UDP 协议，每个数据报最大的字节数为： 576 - 20 - 8 = 548

####1.4.3 数据有序性的差异
* TCP

对于 TCP 来说，本身 TCP 有着超时重传、错误重传、还有等等一系列复杂的算法保证了 TCP 的数据是有序的，假设你发送了数据 1、2、3，则只要发送端和接收端保持连接时，接收端收到的数据始终都是 1、2、3。

* UDP

无论 server 端无论缓冲池的大小有多大，接收 client 端发来的消息总是一个一个的接收。并且由于 UDP 本身的不可靠性以及无序性，如果 client 发送了 1、2、3 这三个数据报过来，server 端接收到的可能是任意顺序、任意个数三个数据报的排列组合。

####1.4.4 可靠性差异
* TCP

TCP 内部的很多算法机制让他保持连接的过程中是很可靠的。比如：TCP 的超时重传、错误重传、TCP 的流量控制、阻塞控制、慢热启动算法、拥塞避免算法、快速恢复算法 等等。所以 TCP 是一个内部原理复杂，但是使用起来比较简单的这么一个协议。

* UDP

UDP 是一个面向非连接的协议，UDP 发送的每个数据报带有自己的 IP 地址和接收方的 IP 地址，它本身对这个数据报是否出错，是否到达不关心，只要发出去了就好了。

什么情况下会导致UDP丢包：

* 数据报分片重组丢失：

在文章之前我们就说过，UDP 的每个数据报大小多少最合适，事实上 UDP 协议本身规定的大小是 64kb，但是在数据链路层有 MTU 的限制，大小大概在 5kb，所以当你发送一个很大的 UDP 包的时候，这个包会在 IP 层进行分片，然后重组。这个过程就有可能导致分片的包丢失。UDP 本身有 CRC 检测机制，会抛弃掉丢失的 UDP 包；

* UDP 缓冲区填满：

当 UDP 的缓冲区已经被填满的时候，接收方还没有处理这部分的 UDP 数据报，这个时候再过来的数据报就没有地方可以存了，自然就都被丢弃了。

####1.4.5 使用场景总结
有很多人都会觉得 UDP 与 TCP 相比，在性能速度上是占优势的。因为 UDP 并不用保持一个持续的连接，也不需要对收发包进行确认。但事实上经过这么多年的发展 TCP 已经拥有足够多的算法和优化，在网络状态不错的情况下，TCP 的整体性能是优于 UDP 的。

什么时候必须使用UDP呢？

* 对实时性要求高：

比如实时会议，实时视频这种情况下，如果使用 TCP，当网络不好发生重传时，画面肯定会有延时，甚至越堆越多。如果使用 UDP 的话，即使偶尔丢了几个包，但是也不会影响什么，这种情况下使用 UDP 比较好

* 多点通信：

TCP 需要保持一个长连接，那么在涉及多点通讯的时候，肯定需要和多个通信节点建立其双向连接，然后有时在NAT环境下，两个通信节点建立其直接的 TCP 连接不是一个容易的事情，而 UDP 可以无需保持连接，直接发就可以了，所以成本会很低，而且穿透性好。这种情况下使用 UDP 也是没错的。

以上我们说了 UDP 的使用场景，在此之外的其他情况，使用 TCP 准没错。

when in doubt ， use TCP

#### 1.4.6 如今UDP对比TCP的更多优势

* 网速的提升给UDP稳定性提供可靠网络保障

网络环境变好，网络传输的延迟、稳定性也随之改善，UDP的丢包率低于5%，如果再使用应用层重传，能够完全确保传输的可靠性。

* 对比测试结果UDP性能优于TCP

为了提升浏览速度，Google基于TCP提出了SPDY协议以及HTTP/2。Google在Chrome上实验基于UDP的QUIC协议，传输速率减少到100ms以内。

Google采用QUIC后连接速率能有效提升75%；
Google搜索采用QUIC后页面加载性能提升3%；
YouTube采用QUIC后重新缓冲次数减少了30%。

* TCP设计过于冗余，速度难以进一步提升

TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程以及重传策略。由于TCP内置在系统协议栈中，极难对其进行改进。 

* UDP协议以其简单、传输快的优势，在越来越多场景下取代了TCP

1） 网页浏览

1. 能够对握手过程进行精简，减少网络通信往返次数；
2. 能够对TLS加解密过程进行优化；
3. 收发快速，无阻塞。

2） 流媒体

采用TCP，一旦发生丢包，TCP会将后续包缓存起来，等前面的包重传并接收到后再继续发送，延迟会越来越大。基于UDP的协议如实时音视频开源工程WebRTC是极佳的选择。

3）实时游戏

对实时要求较为严格的情况下，采用自定义的可靠UDP协议，比如Enet、RakNet（用户有 sony online game、minecraft）等，自定义重传策略，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成的影响。

采用UDP的经典游戏如FPS游戏Quake、CS，著名的游戏引擎Unity3D采用的也是RakNet。

4）物联网

2014年google旗下的Nest建立Thread Group，推出了物联网通信协议Thread，完善物联网通信。

采用UDP的三个关键点：

1. 网络带宽需求较小，而实时性要求高；
2. 大部分应用无需维持连接；
3. 需要低功耗。

###1.5 HTTP协议

####1.5.1 HTTP报文在TCP/IP 通信传输流

![HTTP请求传输过程](http://www.52im.net/data/attachment/forum/201806/15/150028yd5rdd9ty7tg09tc.png)

1）建立 TCP 连接：在HTTP工作开始之前，客户端首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，该协议与 IP 协议共同构建 Internet，即著名的 TCP/IP 协议族，因此 Internet 又被称作是 TCP/IP 网络。HTTP 是比 TCP 更高层次的应用层协议，根据规则，只有低层协议建立之后，才能进行高层协议的连接，因此，首先要建立 TCP 连接，一般 TCP 连接的端口号是80；

2）客户端向服务器发送请求命令：一旦建立了TCP连接，客户端就会向服务器发送请求命令；
例如：GET/sample/hello.jsp HTTP/1.1；

3）客户端发送请求头信息：客户端发送其请求命令之后，还要以头信息的形式向服务器发送一些别的信息，之后客户端发送了一空白行来通知服务器，它已经结束了该头信息的发送；

4）服务器应答：客户端向服务器发出请求后，服务器会客户端返回响应；
例如： HTTP/1.1 200 OK
响应的第一部分是协议的版本号和响应状态码；

5）服务器返回响应头信息：正如客户端会随同请求发送关于自身的信息一样，服务器也会随同响应向用户发送关于它自己的数据及被请求的文档；

6）服务器向客户端发送数据：服务器向客户端发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以 Content-Type 响应头信息所描述的格式发送用户所请求的实际数据；

7）服务器关闭 TCP 连接：一般情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接，然后如果客户端或者服务器在其头信息加入了这行代码 Connection:keep-alive ，TCP 连接在发送后将仍然保持打开状态，于是，客户端可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。

####1.5.2 HTTP协议基础

* 通过请求和响应的交换达成通信

应用 HTTP 协议时，必定是一端担任客户端角色，另一端担任服务器端角色。仅从一条通信线路来说，服务器端和客服端的角色是确定的。HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。

* HTTP是不保存状态的协议

HTTP 是一种无状态协议。协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的。
可是随着 Web 的不断发展，我们的很多业务都需要对通信状态进行保存。于是我们引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。

* 使用 Cookie 的状态管理

ookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。

* 请求 URI 定位资源

HTTP 协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到。

* 告知服务器意图的 HTTP 方法（HTTP/1.1）

![](http://www.52im.net/data/attachment/forum/201806/15/150738p93ccmc9gwcwvo5e.png)

* 持久连接

HTTP 协议的初始版本中，每进行一个 HTTP 通信都要断开一次 TCP 连接。比如使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请求该 HTML 页面里包含的其他资源。因此，每次的请求都会造成无畏的 TCP 连接建立和断开，增加通信量的开销。

为了解决上述 TCP 连接的问题，HTTP/1.1 和部分 HTTP/1.0 想出了持久连接的方法。其特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。旨在建立一次 TCP 连接后进行多次请求和响应的交互。在 HTTP/1.1 中，所有的连接默认都是持久连接。

* 管线化

持久连接使得多数请求以管线化方式发送成为可能。以前发送请求后需等待并接收到响应，才能发送下一个请求。管线化技术出现后，不用等待亦可发送下一个请求。这样就能做到同时并行发送多个请求，而不需要一个接一个地等待响应了。

比如，当请求一个包含多张图片的 HTML 页面时，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术要比持久连接速度更快。请求数越多，时间差就越明显。
